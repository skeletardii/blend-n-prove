{
  "level": 2,
  "description": "Level 2: 2 operations, 2-3 premises",
  "problems": [
    {
      "premises": [
        "P → Q",
        "Q → R",
        "P"
      ],
      "conclusion": "R",
      "expected_operations": 2,
      "description": "Hypothetical Syllogism + MP",
      "solution": "Apply Hypothetical Syllogism to get \"P → R\" from the first two premises, then Modus Ponens with \"P\" to get \"R\"."
    },
    {
      "premises": [
        "P ∧ Q",
        "R"
      ],
      "conclusion": "P ∧ R",
      "expected_operations": 2,
      "description": "Simplification + Conjunction",
      "solution": "Apply Simplification to extract \"P\" from \"P ∧ Q\", then Conjunction to combine \"P\" and \"R\"."
    },
    {
      "premises": [
        "¬¬P",
        "P → Q"
      ],
      "conclusion": "Q",
      "expected_operations": 2,
      "description": "Double Negation + Modus Ponens",
      "solution": "Apply Double Negation to get \"P\" from \"¬¬P\", then Modus Ponens with \"P → Q\" to get \"Q\"."
    },
    {
      "premises": [
        "P ∨ Q",
        "¬P",
        "Q → R"
      ],
      "conclusion": "R",
      "expected_operations": 2,
      "description": "Disjunctive Syllogism + MP",
      "solution": "Apply Disjunctive Syllogism to get \"Q\" from \"P ∨ Q\" and \"¬P\", then Modus Ponens with \"Q → R\" to get \"R\"."
    },
    {
      "premises": [
        "P ∧ (Q ∧ R)"
      ],
      "conclusion": "(Q ∧ R)",
      "expected_operations": 1,
      "description": "Simplification (right)",
      "solution": "Apply Simplification to extract the right conjunct \"(Q ∧ R)\" from \"P ∧ (Q ∧ R)\"."
    },
    {
      "premises": [
        "¬(P ∨ Q)",
        "R → S"
      ],
      "conclusion": "¬P ∧ ¬Q",
      "expected_operations": 1,
      "description": "De Morgan's Law with unused premise",
      "solution": "Apply De Morgan's Law to \"¬(P ∨ Q)\" to get \"(¬P ∧ ¬Q)\". The premise \"R → S\" is not needed."
    },
    {
      "premises": [
        "P",
        "Q",
        "R"
      ],
      "conclusion": "(P ∧ Q) ∧ R",
      "expected_operations": 2,
      "description": "Conjunction + Conjunction",
      "solution": "Apply Conjunction to combine \"P\" and \"Q\" into \"P ∧ Q\", then apply Conjunction again with \"R\"."
    },
    {
      "premises": [
        "P → (Q ∧ R)",
        "P"
      ],
      "conclusion": "Q",
      "expected_operations": 2,
      "description": "Modus Ponens + Simplification",
      "solution": "Apply Modus Ponens to get \"Q ∧ R\", then Simplification to extract \"Q\"."
    },
    {
      "premises": [
        "(P ∧ Q) → R",
        "P",
        "Q"
      ],
      "conclusion": "R",
      "expected_operations": 2,
      "description": "Conjunction + Modus Ponens",
      "solution": "Apply Conjunction to combine \"P\" and \"Q\" into \"P ∧ Q\", then Modus Ponens to get \"R\"."
    },
    {
      "premises": [
        "P ∨ (Q ∧ R)",
        "¬P"
      ],
      "conclusion": "Q ∧ R",
      "expected_operations": 1,
      "description": "Disjunctive Syllogism",
      "solution": "Apply Disjunctive Syllogism: from \"P ∨ (Q ∧ R)\" and \"¬P\", conclude \"(Q ∧ R)\"."
    },
    {
      "premises": [
        "(P ∧ Q) ∧ R"
      ],
      "conclusion": "P ∧ (Q ∧ R)",
      "expected_operations": 1,
      "description": "Associativity (AND)",
      "solution": "Apply Associativity to regroup the conjuncts: \"(P ∧ Q) ∧ R\" is equivalent to \"P ∧ (Q ∧ R)\"."
    },
    {
      "premises": [
        "(P ∨ Q) ∨ R"
      ],
      "conclusion": "P ∨ (Q ∨ R)",
      "expected_operations": 1,
      "description": "Associativity (OR)",
      "solution": "Apply Associativity to regroup the disjuncts: \"(P ∨ Q) ∨ R\" is equivalent to \"P ∨ (Q ∨ R)\"."
    },
    {
      "premises": [
        "P → Q"
      ],
      "conclusion": "¬P ∨ Q",
      "expected_operations": 1,
      "description": "Implication Conversion",
      "solution": "Apply Implication Conversion (IMP) to convert \"P → Q\" into its equivalent disjunctive form \"(¬P ∨ Q)\"."
    },
    {
      "premises": [
        "P → Q"
      ],
      "conclusion": "¬Q → ¬P",
      "expected_operations": 1,
      "description": "Contrapositive",
      "solution": "Apply Contrapositive transformation (CONV): \"P → Q\" is logically equivalent to \"(¬Q → ¬P)\"."
    },
    {
      "premises": [
        "P ∨ Q",
        "¬P ∨ R"
      ],
      "conclusion": "Q ∨ R",
      "expected_operations": 2,
      "description": "Resolution",
      "solution": "Apply Resolution: from \"P ∨ Q\" and \"¬P ∨ R\", resolve on P to get \"(Q ∨ R)\"."
    },
    {
      "premises": [
        "P ∨ (P ∧ Q)",
        "R"
      ],
      "conclusion": "P ∧ R",
      "expected_operations": 2,
      "description": "Absorption + Conjunction",
      "solution": "Apply Absorption to simplify \"P ∨ (P ∧ Q)\" to \"P\", then Conjunction with \"R\" to get \"(P ∧ R)\"."
    },
    {
      "premises": [
        "P ∧ (Q ∨ R)",
        "¬Q"
      ],
      "conclusion": "P ∧ R",
      "expected_operations": 2,
      "description": "Simplification + Disjunctive Syllogism + Conjunction",
      "solution": "Apply Simplification to extract \"P\" and \"Q ∨ R\", then Disjunctive Syllogism with \"¬Q\" to get \"R\", finally Conjunction to combine \"P\" and \"R\"."
    },
    {
      "premises": [
        "P ↔ Q",
        "P"
      ],
      "conclusion": "Q",
      "expected_operations": 2,
      "description": "Biconditional Elimination + Modus Ponens",
      "solution": "Apply Biconditional Elimination to extract \"P → Q\" from \"P ↔ Q\", then Modus Ponens with \"P\" to conclude \"Q\"."
    },
    {
      "premises": [
        "P ∨ Q",
        "P → R",
        "Q → R"
      ],
      "conclusion": "R",
      "expected_operations": 2,
      "description": "Proof by Cases",
      "solution": "Since we have P ∨ Q, we know either P or Q is true. If P is true, then R follows from P → R. If Q is true, then R follows from Q → R. Either way, R must be true. Apply Constructive Dilemma or case-by-case analysis."
    },
    {
      "premises": [
        "R ∧ (R ∨ S)",
        "T"
      ],
      "conclusion": "R ∧ T",
      "expected_operations": 2,
      "description": "Absorption + Conjunction",
      "solution": "Apply Absorption to simplify \"R ∧ (R ∨ S)\" to \"R\", then Conjunction with \"T\" to get \"R ∧ T\"."
    },
    {
      "natural_language_premises": [
        "Either the door is locked (P) or the window is open (Q).",
        "The door is not locked (¬P).",
        "If the window is open (Q), then we need to close it (R)."
      ],
      "hidden_logical_premises": ["P ∨ Q", "¬P", "Q → R"],
      "natural_language_conclusion": "We need to close the window (R).",
      "hidden_logical_conclusion": "R",
      "expected_operations": 2,
      "description": "Disjunctive Syllogism followed by Modus Ponens",
      "solution": "Translate: P = 'Door is locked', Q = 'Window is open', R = 'Need to close window'. Apply Disjunctive Syllogism with P ∨ Q and ¬P to get Q, then apply Modus Ponens with Q → R to conclude R.",
      "interpretation_hints": ["Eliminate the false option from the disjunction first", "Then use the remaining option with the conditional"]
    },
    {
      "natural_language_premises": [
        "If it rains (P), then the ground gets wet (Q).",
        "If the ground is wet (Q), then the plants thrive (R).",
        "It is raining (P)."
      ],
      "hidden_logical_premises": ["P → Q", "Q → R", "P"],
      "natural_language_conclusion": "The plants thrive (R).",
      "hidden_logical_conclusion": "R",
      "expected_operations": 2,
      "description": "Hypothetical Syllogism followed by Modus Ponens",
      "solution": "Translate: P = 'It rains', Q = 'Ground gets wet', R = 'Plants thrive'. Apply Hypothetical Syllogism with P → Q and Q → R to get P → R, then apply Modus Ponens with P to conclude R.",
      "interpretation_hints": ["Chain the conditionals together first", "Then apply the known condition"]
    },
    {
      "natural_language_premises": [
        "If the package is fragile (P), then it must be handled carefully (Q).",
        "The package is fragile (P).",
        "If something must be handled carefully (Q), then workers wear gloves (R)."
      ],
      "hidden_logical_premises": ["P → Q", "P", "Q → R"],
      "natural_language_conclusion": "Workers wear gloves (R).",
      "hidden_logical_conclusion": "R",
      "expected_operations": 2,
      "description": "Modus Ponens twice in sequence",
      "solution": "Translate: P = 'Package fragile', Q = 'Handle carefully', R = 'Wear gloves'. Apply Modus Ponens to P → Q and P to get Q. Apply Modus Ponens to Q → R and Q to get R.",
      "interpretation_hints": ["First conclusion becomes a premise for next step", "Chain the applications together"]
    },
    {
      "natural_language_premises": [
        "If the battery is dead (P), then the phone does not work (Q).",
        "The phone does not work (Q).",
        "If the phone does not work (Q), then we cannot call for help (R)."
      ],
      "hidden_logical_premises": ["P → Q", "Q", "Q → R"],
      "natural_language_conclusion": "We cannot call for help (R).",
      "hidden_logical_conclusion": "R",
      "expected_operations": 2,
      "description": "Two-step implication from consequence",
      "solution": "Translate: P = 'Battery dead', Q = 'Phone broken', R = 'Cannot call help'. Apply Modus Ponens to Q → R and Q to get R.",
      "interpretation_hints": ["The second conditional follows from the first consequence", "Apply implications in sequence"]
    },
    {
      "natural_language_premises": [
        "Either the document is lost (P) or filed correctly (Q).",
        "The document is not lost (¬P).",
        "If the document is filed correctly (Q), then it can be found (R)."
      ],
      "hidden_logical_premises": ["P ∨ Q", "¬P", "Q → R"],
      "natural_language_conclusion": "The document can be found (R).",
      "hidden_logical_conclusion": "R",
      "expected_operations": 2,
      "description": "Disjunctive Syllogism then Modus Ponens",
      "solution": "Translate: P = 'Document lost', Q = 'Filed correctly', R = 'Can be found'. Apply Disjunctive Syllogism to P ∨ Q and ¬P to get Q. Apply Modus Ponens to Q → R and Q to get R.",
      "interpretation_hints": ["Determine which option is true from disjunction", "Then apply that option to the conditional"]
    },
    {
      "natural_language_premises": [
        "If the plants need water (P), then the soil is dry (Q).",
        "If the soil is dry (Q), then the leaves wilt (R).",
        "The plants need water (P)."
      ],
      "hidden_logical_premises": ["P → Q", "Q → R", "P"],
      "natural_language_conclusion": "The leaves wilt (R).",
      "hidden_logical_conclusion": "R",
      "expected_operations": 2,
      "description": "Hypothetical Syllogism with nature scenario",
      "solution": "Translate: P = 'Plants need water', Q = 'Soil is dry', R = 'Leaves wilt'. Apply Hypothetical Syllogism to get P → R, then apply Modus Ponens with P to get R.",
      "interpretation_hints": ["Build the complete chain through two implications", "Apply the initial fact through the chain"]
    },
    {
      "natural_language_premises": [
        "If the contract is signed (P), then work begins (Q).",
        "The contract is signed (P).",
        "If work begins (Q), then the team is assembled (R).",
        "The team is assembled (R) or the project is postponed (S)."
      ],
      "hidden_logical_premises": ["P → Q", "P", "Q → R", "R ∨ S"],
      "natural_language_conclusion": "Either the team is assembled or the project is postponed (R ∨ S).",
      "hidden_logical_conclusion": "R ∨ S",
      "expected_operations": 2,
      "description": "Chained Modus Ponens with disjunction",
      "solution": "Translate: P = 'Contract signed', Q = 'Work begins', R = 'Team assembled', S = 'Project postponed'. Apply Modus Ponens to P → Q and P to get Q. Apply Modus Ponens to Q → R to get R. R already satisfies R ∨ S.",
      "interpretation_hints": ["Chain implications to reach R", "R makes the final disjunction true"]
    },
    {
      "natural_language_premises": [
        "Either the game is forfeited (P) or it is played (Q).",
        "The game is not forfeited (¬P).",
        "If the game is played (Q), then tickets are sold (R)."
      ],
      "hidden_logical_premises": ["P ∨ Q", "¬P", "Q → R"],
      "natural_language_conclusion": "Tickets are sold (R).",
      "hidden_logical_conclusion": "R",
      "expected_operations": 2,
      "description": "Disjunctive Syllogism with conditional",
      "solution": "Translate: P = 'Game forfeited', Q = 'Game played', R = 'Tickets sold'. Apply Disjunctive Syllogism to P ∨ Q and ¬P to get Q. Apply Modus Ponens to Q → R and Q to get R.",
      "interpretation_hints": ["Eliminate the false option", "Use result to trigger next conditional"]
    },
    {
      "natural_language_premises": [
        "If the software is updated (P), then bugs are fixed (Q).",
        "If bugs are fixed (Q), then the program runs smoothly (R).",
        "The software is not updated (¬P)."
      ],
      "hidden_logical_premises": ["P → Q", "Q → R", "¬P"],
      "natural_language_conclusion": "We cannot conclude the program runs smoothly (we need P to be true).",
      "hidden_logical_conclusion": "None",
      "expected_operations": 2,
      "description": "Chain with negated condition (red herring)",
      "solution": "Translate: P = 'Software updated', Q = 'Bugs fixed', R = 'Program smooth'. We have ¬P, so we cannot use P → Q with Modus Ponens. The chain is broken; no conclusion can be drawn about R.",
      "interpretation_hints": ["Not all premises lead to a conclusion", "The negated condition breaks the forward chain", "This is a test of understanding when rules apply"]
    }
  ]
}