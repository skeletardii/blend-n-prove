{
  "level": 5,
  "description": "Level 5: 4+ operations, 4-6 premises",
  "problems": [
    {
      "premises": [
        "P → (Q ∧ R)",
        "Q → S",
        "R → T",
        "P"
      ],
      "conclusion": "S ∧ T",
      "expected_operations": 5,
      "description": "Complex branching chain",
      "solution": "Apply Modus Ponens to get \"Q ∧ R\", extract \"Q\" and \"R\", apply Modus Ponens to each to get \"S\" and \"T\", combine via Conjunction."
    },
    {
      "premises": [
        "P → (Q ∧ R)",
        "Q → S",
        "R → T",
        "P"
      ],
      "conclusion": "S ∧ T",
      "expected_operations": 4,
      "description": "Multi-branch convergence",
      "solution": "Apply Modus Ponens on \"P → (Q ∧ R)\" with \"P\" to get \"Q ∧ R\". Extract \"Q\" and \"R\" via Simplification. Apply Modus Ponens on \"Q → S\" to get \"S\" and on \"R → T\" to get \"T\". Finally, combine \"S\" and \"T\" via Conjunction."
    },
    {
      "premises": [
        "(P ∧ Q) → (R ∨ S)",
        "(R ∨ S) → T",
        "P",
        "Q"
      ],
      "conclusion": "T",
      "expected_operations": 5,
      "description": "Chain of implications",
      "solution": "Combine \"P\" and \"Q\", apply Modus Ponens to get \"R ∨ S\", then Modus Ponens again to get \"T\"."
    },
    {
      "premises": [
        "P ∨ Q",
        "¬P ∨ R",
        "¬Q ∨ R"
      ],
      "conclusion": "R",
      "expected_operations": 5,
      "description": "Resolution-style proof",
      "solution": "Apply Resolution techniques: from the three disjunctions, deduce that \"R\" must be true through case analysis."
    },
    {
      "premises": [
        "(P → Q) ∧ (R → S)",
        "¬Q ∨ ¬S",
        "P ∨ R"
      ],
      "conclusion": "¬P ∨ ¬R",
      "expected_operations": 5,
      "description": "Complex Modus Tollens",
      "solution": "Extract the implications, use De Morgan's logic with \"¬Q ∨ ¬S\" to derive that at least one antecedent must be false."
    },
    {
      "premises": [
        "¬¬(P ∧ Q)",
        "P → R",
        "Q → S"
      ],
      "conclusion": "R ∧ S",
      "expected_operations": 5,
      "description": "Double negation + parallel inference",
      "solution": "Apply Double Negation to get \"P ∧ Q\", extract \"P\" and \"Q\", apply Modus Ponens to each to get \"R\" and \"S\", combine via Conjunction."
    },
    {
      "premises": [
        "P → Q",
        "R → S",
        "(Q ∧ S) → T",
        "P",
        "R"
      ],
      "conclusion": "T",
      "expected_operations": 5,
      "description": "Convergent proof",
      "solution": "Apply Modus Ponens twice to get \"Q\" and \"S\", combine via Conjunction, then Modus Ponens to get \"T\"."
    },
    {
      "premises": [
        "(P ∨ Q) → (R ∧ S)",
        "P",
        "¬R → T",
        "¬T"
      ],
      "conclusion": "R ∧ S",
      "expected_operations": 5,
      "description": "Proof by contradiction",
      "solution": "Use Addition to get \"P ∨ Q\", apply Modus Ponens to get \"R ∧ S\". The premises about \"T\" help verify \"R\" must be true."
    },
    {
      "premises": [
        "P ⊕ Q",
        "P → R",
        "Q → R"
      ],
      "conclusion": "R",
      "expected_operations": 5,
      "description": "XOR elimination to common conclusion",
      "solution": "XOR means exactly one of \"P\" or \"Q\" is true. Either way, both lead to \"R\" via Modus Ponens, so \"R\" must be true."
    },
    {
      "premises": [
        "(P → Q) ∧ (R → S)",
        "P ∨ R",
        "¬Q ∨ ¬S",
        "T"
      ],
      "conclusion": "T ∧ (¬P ∨ ¬R)",
      "expected_operations": 5,
      "description": "Constructive + Destructive Dilemma",
      "solution": "Extract implications, apply Constructive Dilemma to get \"Q ∨ S\", then Destructive Dilemma with \"¬Q ∨ ¬S\" to get \"¬P ∨ ¬R\", combine with \"T\"."
    },
    {
      "premises": [
        "(P ∧ Q) ∨ (P ∧ R)",
        "Q → S",
        "R → T"
      ],
      "conclusion": "P ∧ (S ∨ T)",
      "expected_operations": 5,
      "description": "Reverse Distributivity + Case Analysis",
      "solution": "Factor to get \"P ∧ (Q ∨ R)\", extract \"P\" and \"Q ∨ R\". Use case analysis: if Q then S, if R then T, so \"S ∨ T\". Combine with P."
    },
    {
      "premises": [
        "P ∨ Q",
        "¬P ∨ R",
        "¬Q ∨ S",
        "¬R ∨ T"
      ],
      "conclusion": "S ∨ T",
      "expected_operations": 5,
      "description": "Advanced Resolution Chain",
      "solution": "Resolve \"P ∨ Q\" with \"¬P ∨ R\" to get \"Q ∨ R\", then with \"¬Q ∨ S\" to get \"R ∨ S\", finally with \"¬R ∨ T\" to get \"S ∨ T\"."
    },
    {
      "premises": [
        "P ⊕ Q",
        "Q ⊕ R",
        "P → S",
        "R → S"
      ],
      "conclusion": "S",
      "expected_operations": 5,
      "description": "Multiple XOR Analysis",
      "solution": "From XORs, analyze cases: if P then ¬Q (from first XOR), if ¬Q then R (from second XOR), so P → R. But we also have P → S and R → S, so S holds in all cases."
    },
    {
      "premises": [
        "P → (Q ∧ R)",
        "Q → S",
        "R → S",
        "P"
      ],
      "conclusion": "S",
      "expected_operations": 4,
      "description": "Multi-branch Convergent Proof",
      "solution": "Apply Modus Ponens to get \"Q ∧ R\", extract both \"Q\" and \"R\" via Simplification. Apply Modus Ponens on \"Q → S\" to get \"S\" (or alternatively use \"R → S\"). Either path leads to \"S\"."
    },
    {
      "premises": [
        "P → (Q ∨ R)",
        "¬Q",
        "R → S",
        "S → T",
        "P"
      ],
      "conclusion": "T",
      "expected_operations": 5,
      "description": "Complex Chain with Disjunctive Syllogism",
      "solution": "Apply Modus Ponens on \"P → (Q ∨ R)\" with \"P\" to get \"Q ∨ R\". Apply Disjunctive Syllogism with \"¬Q\" to get \"R\". Chain through \"R → S\" and \"S → T\" using Modus Ponens twice to get \"T\"."
    },
    {
      "premises": [
        "(P ∧ Q) → R",
        "(R ∧ S) → T",
        "(T ∧ U) → V",
        "P",
        "Q",
        "S",
        "U"
      ],
      "conclusion": "V",
      "expected_operations": 5,
      "description": "Multi-level Nested Implications",
      "solution": "Combine \"P\" and \"Q\" to get \"P ∧ Q\", apply Modus Ponens to get \"R\". Combine \"R\" and \"S\" to get \"R ∧ S\", apply Modus Ponens to get \"T\". Combine \"T\" and \"U\" to get \"T ∧ U\", apply Modus Ponens to get \"V\"."
    },
    {
      "premises": [
        "P ∧ (Q ∨ (R ∧ S))",
        "¬Q",
        "R → T"
      ],
      "conclusion": "P ∧ S ∧ T",
      "expected_operations": 5,
      "description": "Complex Nested Distributivity",
      "solution": "Extract \"P\" and \"Q ∨ (R ∧ S)\". Use Disjunctive Syllogism with \"¬Q\" to get \"R ∧ S\". Extract \"R\" and \"S\", apply Modus Ponens to get \"T\", combine all."
    },
    {
      "premises": [
        "(P ∧ Q) → R",
        "(R ∧ S) → T",
        "P",
        "Q",
        "S"
      ],
      "conclusion": "T",
      "expected_operations": 4,
      "description": "Nested conjunctive antecedents",
      "solution": "Combine \"P\" and \"Q\" via Conjunction to get \"P ∧ Q\", apply Modus Ponens with \"(P ∧ Q) → R\" to get \"R\". Combine \"R\" and \"S\" via Conjunction to get \"R ∧ S\", apply Modus Ponens with \"(R ∧ S) → T\" to get \"T\"."
    },
    {
      "natural_language_premises": [
        "If the meeting is scheduled (P), then the presentation is prepared (Q).",
        "If the presentation is prepared (Q), then slides are created (R).",
        "If slides are created (R), then graphics are designed (S).",
        "If graphics are designed (S), then the presentation is professional (T).",
        "If the presentation is professional (T), then executives approve it (U).",
        "The meeting is scheduled (P).",
        "The office has projector equipment (V)."
      ],
      "hidden_logical_premises": [
        "P → Q",
        "Q → R",
        "R → S",
        "S → T",
        "T → U",
        "P",
        "V"
      ],
      "natural_language_conclusion": "Executives approve the presentation (U).",
      "hidden_logical_conclusion": "U",
      "expected_operations": 5,
      "description": "Five-step implication chain with multiple dependencies",
      "solution": "Translate: P = 'Meeting scheduled', Q = 'Presentation prepared', R = 'Slides created', S = 'Graphics designed', T = 'Professional', U = 'Executives approve', V = 'Has projector'. Chain all five conditionals using Hypothetical Syllogism four times to build P → U, then apply Modus Ponens with P to conclude U.",
      "interpretation_hints": [
        "Build the complete five-step chain",
        "Each step leads to the next",
        "One fact is irrelevant to the final conclusion"
      ]
    },
    {
      "natural_language_premises": [
        "If the architect approves the design (P), then both construction permits are obtained (Q) and materials are ordered (R).",
        "If construction permits are obtained (Q), then site preparation begins (S).",
        "If site preparation begins (S), then equipment is set up (U).",
        "If equipment is set up (U), then workers begin building (V).",
        "The architect approves the design (P)."
      ],
      "hidden_logical_premises": [
        "P → (Q ∧ R)",
        "Q → S",
        "S → U",
        "U → V",
        "P"
      ],
      "natural_language_conclusion": "Workers begin building (V).",
      "hidden_logical_conclusion": "V",
      "expected_operations": 4,
      "description": "Complex multi-branch convergence",
      "solution": "Translate: P = 'Design approved', Q = 'Permits obtained', R = 'Materials ordered', S = 'Site prep begins', U = 'Equipment set up', V = 'Workers building'. Apply Modus Ponens to P → (Q ∧ R) to get Q ∧ R. Extract Q. Chain Q → S → U → V using Hypothetical Syllogism to get Q → V, apply to get V.",
      "variable_definitions": {
        "P": "the architect approves the design",
        "Q": "construction permits are obtained",
        "R": "materials are ordered",
        "S": "site preparation begins",
        "U": "equipment is set up",
        "V": "workers begin building"
      },
      "interpretation_hints": [
        "Handle compound consequents carefully",
        "Follow the path that leads to the conclusion"
      ]
    },
    {
      "natural_language_premises": [
        "Either the patent application is approved (P) or denied (Q).",
        "If the patent is approved (P), then both the invention is protected (R) and licensing opportunities arise (S).",
        "If the invention is protected (R), then competitors cannot copy (T).",
        "If competitors cannot copy (T), then market share is preserved (V).",
        "The patent is not denied (¬Q)."
      ],
      "hidden_logical_premises": [
        "P ∨ Q",
        "P → (R ∧ S)",
        "R → T",
        "T → V",
        "¬Q"
      ],
      "natural_language_conclusion": "Market share is preserved (V).",
      "hidden_logical_conclusion": "V",
      "expected_operations": 4,
      "description": "Disjunctive entry with branching convergence",
      "solution": "Translate: P = 'Patent approved', Q = 'Patent denied', R = 'Invention protected', S = 'License opportunities', T = 'No copying', V = 'Market share preserved'. From P ∨ Q and ¬Q, deduce P. Apply Modus Ponens to P → (R ∧ S) to get R ∧ S. Extract R. Apply Modus Ponens to R → T and T → V to conclude V.",
      "variable_definitions": {
        "P": "the patent application is approved",
        "Q": "it is denied",
        "R": "the invention is protected",
        "S": "licensing opportunities arise",
        "T": "competitors cannot copy",
        "V": "market share is preserved"
      },
      "interpretation_hints": [
        "Eliminate one option from disjunction",
        "Handle compound consequent",
        "Follow the relevant path to the conclusion"
      ]
    },
    {
      "natural_language_premises": [
        "If the software team is hired (P), then both development begins (Q) and testing framework is set up (R).",
        "If development begins (Q), then features are coded (S).",
        "If features are coded (S), then the application is built (T).",
        "If the application is built (T), then performance optimization occurs (V).",
        "The software team is hired (P)."
      ],
      "hidden_logical_premises": [
        "P → (Q ∧ R)",
        "Q → S",
        "S → T",
        "T → V",
        "P"
      ],
      "natural_language_conclusion": "Performance optimization occurs (V).",
      "hidden_logical_conclusion": "V",
      "expected_operations": 5,
      "description": "Parallel development chains converging",
      "solution": "Translate: P = 'Team hired', Q = 'Development begins', R = 'Testing set up', S = 'Features coded', T = 'App built', V = 'Optimization done'. Apply Modus Ponens to P → (Q ∧ R) to get Q ∧ R. Build chain Q → S → T → V. Apply Modus Ponens through the chain to conclude V.",
      "variable_definitions": {
        "P": "the software team is hired",
        "Q": "development begins",
        "R": "the testing framework is set up",
        "S": "features are coded",
        "T": "the application is built",
        "V": "performance optimization occurs"
      },
      "interpretation_hints": [
        "Extract components from compound consequent",
        "Follow the main development track"
      ]
    },
    {
      "natural_language_premises": [
        "Either the manufacturing process is optimized (P) or costs remain high (Q).",
        "If the manufacturing process is optimized (P), then both waste is reduced (R) and efficiency improves (S).",
        "If waste is reduced (R), then material costs decrease (T).",
        "If material costs decrease (T), then the company's expenses drop (V).",
        "The manufacturing process is optimized (P)."
      ],
      "hidden_logical_premises": [
        "P ∨ Q",
        "P → (R ∧ S)",
        "R → T",
        "T → V",
        "P"
      ],
      "natural_language_conclusion": "The company's expenses drop (V).",
      "hidden_logical_conclusion": "V",
      "expected_operations": 4,
      "description": "Disjunctive optimization with competitive outcome",
      "solution": "Translate: P = 'Process optimized', Q = 'Costs high', R = 'Waste reduced', S = 'Efficiency improves', T = 'Material costs drop', V = 'Expenses drop'. P is true, so follow P → (R ∧ S) to get R ∧ S. Build R → T → V. Apply Modus Ponens to conclude V.",
      "variable_definitions": {
        "P": "the manufacturing process is optimized",
        "Q": "costs remain high",
        "R": "waste is reduced",
        "S": "efficiency improves",
        "T": "material costs decrease",
        "V": "the company's expenses drop"
      },
      "interpretation_hints": [
        "Confirm disjunction path is satisfied",
        "Extract compound consequences",
        "Follow the cost reduction path"
      ]
    },
    {
      "natural_language_premises": [
        "If the environmental sustainability initiative is launched (P), then both green technologies are adopted (Q) and employee engagement increases (R).",
        "If employee engagement increases (R), then talent retention improves (T).",
        "If talent retention improves (T), then institutional knowledge grows (V).",
        "The environmental sustainability initiative is launched (P)."
      ],
      "hidden_logical_premises": [
        "P → (Q ∧ R)",
        "R → T",
        "T → V",
        "P"
      ],
      "natural_language_conclusion": "Institutional knowledge grows (V).",
      "hidden_logical_conclusion": "V",
      "expected_operations": 4,
      "description": "Sustainability-driven outcome",
      "solution": "Translate: P = 'Launch initiative', Q = 'Green tech adopted', R = 'Engagement increases', T = 'Retention improves', V = 'Knowledge grows'. Apply Modus Ponens to P → (Q ∧ R) to get Q ∧ R. Extract R. Chain R → T → V. Apply Modus Ponens to conclude V.",
      "variable_definitions": {
        "P": "the environmental sustainability initiative is launched",
        "Q": "green technologies are adopted",
        "R": "employee engagement increases",
        "T": "talent retention improves",
        "V": "institutional knowledge grows"
      },
      "interpretation_hints": [
        "Extract both components from compound consequent",
        "One path develops organizational capability"
      ]
    }
  ]
}